---
title: CS2105 notes
tags: Module, CS2105
---

# Lecture 1: Introduction


## 1.3 Network core

i.e. A mesh of interconnected routers

### Circuit switching

End-to-end resources allocated and **reserved** for "call" between source and destination.

- Require setup
- Circuit-like (guaranteed) performance
- No sharing: circuit segment idle if not used by call
- Divide link bandwidth into pieces by
  - frequency division
  - time division

### Packet switching

- Break message into **packets** of length $L$ bits
- transmits packets onto the link at transmission rate $R$
  - transmission rate = link capacity / bandwidth

![](https://i.imgur.com/uxAhepE.png)

**Note:** *transmission rate* = $L / t$ 所以单位是 bits/sec (bps)

Compared with *circuit switching*:

- The Internet is a packet switching network
- User A, B ... ’s packets **share** network resources
- Resources are used on demand
- Excessive congestion is possible (No guaranteed performance)

#### Store-and-forward

i.e. **entire** packet must arrive at a router before it can be transmitted on the next link

#### Routing and Addressing

*Routing algo*: how routers determine source-destination route taken by packets.

*Addressing*: each packet needs to carry source and
destination information


### Internet structure

The Internet is a **“network-of-networks”**, organized into autonomous systems (AS), each is owned by an organization.

![](https://i.imgur.com/kehyaRz.png)

## 1.4 Delay, Loss and Throughput in Networks

### Delay

#### Four sources of packet delay

- Processing delay
  - check bit errors
  - determine output link
  - typically < milliseconds
- Queuing delay
  - time waiting in the queue for transmission
  - depends on congestion level of router
- Transmission delay
  - $L$: packet length (bit)
  - $R$: link bandwidth (bps)
  - $D_{trans} = L / R$ (s)
- Propagation delay
  - d: length of physical link (m)
  - s: propagation speed in medium ($\approx2*10^8$ m/s)
  - $d_{prop} = d/s$ (s)

**Note:** *transmission delay* 指的是packet从第一个bit到最后一个bit全部进入link的时间，*propagation delay*指的是每一个bit从source到destination的时间

#### End-to-end packet delay

i.e. the time taken for a packet to travel from source to destination

### Loss

- Queue (aka buffer) of a router has finite capacity.
- Packet arriving to full queue will be dropped (aka lost).
- Lost packet may be
  - re-transmitted by previous node
  - by source host
  - or not at all.

### Throughput

i.e. how many bits can be transmitted per unit time

- measured for **end-to-end** communication (not on a specific link, but the end result of the packet traveling through all the links)
- Link capacity (bandwidth) is meant for a specific link

## 1.5 Protocol Layers and Service Models

### Protocol **layers**

- Protocols in the Internet are logically organized into “layers” according to their purposes.
  - Each layer provides a service
  - Simple interfaces between layers
  - Hide details from each other

### Internet protocol stack

- application
- transport
- network
- link
- physical

![](https://i.imgur.com/CBuIBco.png)

![](https://i.imgur.com/2K5TueY.png)

![](https://i.imgur.com/l14k82w.png)


---

# Lecture 2/3: Application Layer

## 2.1 Principles of network applications

* Classic structures
  * Client-server
    * server waits for incoming requests
    * client initiates contact with server
  * Peer-to-peer (P2P)
    * no always-on server
    * self scalability -> new peers = new service capacity = new service demands
* Metrics for a transport service
  * Data integrity
  * Timing
  * Throughput
  * Security
* Application protocols define
  * types of messages
  * message syntax
  * message semantics
  * rules for when and how app sends/responds to messages
* Transport protocols
  * TCP
    * reliable
    * flow control: sender won't overwhelm receiver
    * congestion control: throttle sender when network is overloaded
    * WITHOUT: timing, throughput guarantee, security
  * UDP
    * unreliable
    * WITHOUT: well, everything...

## 2.2 Web and HTTP

### HTTP overview

* Hypertext transfer protocol
  * client-server model
  * uses **TCP** as transport service
  * Two types
    * non-persistent HTTP
      * at most one object sent over one TCP connection
      * connection closed thereafter
      * downloading multiple objects requires multiple connections
    * persistent HTTP

### Response time

**RTT:** (Round trip time) time for a packet to travel from client to server and go back

**HTTP response time:** 
* one RTT -> establish TCP conn
* one RTT -> HTTP request and the first few bytes of HTTP response
* file transmission time

Thus, non-persistent HTTP response time = $2*RTT + T_{File Transmission}$

Solution: parallel TCP connections

### Persistent HTTP

* one RTT for all referenced objects
* server leaves conn open after response
  * subsequent HTTP messages are sent over the same TCP conn
* Persistent with pipelining
  * client may send requests as soon as it encounters a referenced object

### HTTP message

#### Request

![](https://i.imgur.com/3Ivmd82.png)

Format:

![](https://i.imgur.com/GMP71ub.png)

Request method types:

* HTTP/1.0:
  * GET
  * POST
    * web page often includes form input
    * input is uploaded to server in entity body
  * HEAD
    * asks server to leave requested object out of response
* HTTP/1.1:
  * GET, POST, HEAD
  * PUT
    * uploads file in entity body to path specified in URL field
  * DELETE
    * deletes file specified in the URL field

##### Conditional `GET`

![](https://i.imgur.com/kormau2.png)


#### Response

![](https://i.imgur.com/1xCyOtR.png)

#### Cookies

Cookies: HTTP messages that carry “state”

Where?

1) cookie header field of HTTP request/ response messages
2) cookie file kept on user’s host, managed by user’s browser
3) back-end database at Web site

![](https://i.imgur.com/9JW2toJ.png)

## 2.4 DNS

Domain name system: Hostname -> IP Address

**DNS run over UDP**

### Resource records (RR)

Mapping between host names and IP addresses (and others) are stored as resource records (RR).

Format: (name, value, type, ttl)

Types:
* A (address)
  * (name -> value)
  * hostname -> IP address
* NS (name server)
  * domain -> hostname of authoritative name server for this domain
* CNAME (canonical name)
  * alias name -> canonical name
* MX (mail exchanger)
  * name -> name of the mail server

### Distributed, hierarchical database of RRs

![](https://i.imgur.com/3n4E9dk.png)

Root servers: Answers requests for records in the root zone by returning a list of the authoritative name servers for the appropriate top-level domain (TLD).

Top-level domain (TLD) servers: responsible for com, org, net, edu, … and all top-level country domains, e.g., uk, sg, jp

Authoritative servers: Organization’s own DNS server(s), providing authoritative hostname to IP mappings for organization’s named hosts (e.g. Web, mail)

#### Local DNS servers

#### DNS caching

Once a name server learns mapping, it cachesmapping.
* cached entries may be out-of-date
* cached entries expire after some time (TTL)
* if name host changes IP address, may not be known Internet-wide until all TTLs expire

#### DNS name resolution

* Recursive
  * ![](https://i.imgur.com/q53czXg.png)
* Iterative
  * ![](https://i.imgur.com/W9Q70y4.png)

## 2.7 Socket programming

* Applications (or processes) treat the Internet as a black box, sending and receiving messages through sockets.
* Two types of sockets
  * TCP: reliable, byte stream-oriented socket
  * UDP: unreliable datagram socket

# Lecture 4&5: The transport layer

## 3.1 Transport layer services

Different names for packets:
* Application layer: message
* Transport layer (process-to-process communication): segments
  * contains source and dest **port numbers**
* Network layer (host-to-host, best effort, unreliable communication): datagram
  * each IP datagram contains source and dest **IP addresses**
  * ~ contains one transport-layer segment

![](https://i.imgur.com/nU3PikP.png)

## UDP: connectionless transport

* On top of IP, UDP adds
  * connectionless multiplexing / de-multiplexing
    * ![](https://i.imgur.com/HMcTfyB.png)
    * IP datagrams (from different sources) with the same destination port # will be directed to the same UDP socket at destination. (i.e. 接收信息的端口也会是应答同一条信息的端口)
  * checksum
    * sender computes the checksum and put the value into the header
    * receiver computes the checksum and compares it against the header's value
    * How to compute?
      * 1. Treat UDP segment as a sequence of 16-bit integers.
      * 2. Apply binary addition on every 16-bit integer(checksum field is currently 0).
      * 3. Carry (if any) from the most significant bit will be added to the result.
      * 4. Compute 1’s complement to get UDP checksum.
* UDP transmission is **unreliable**
  * reliable transmission over UDP can be implemented by applications
    * but with error detection and recovery mechanism of their own

## 3.4 Principles of reliable data transfer

Unreliable network may
* corrupt packets
* drop packets
* deliver packets after an arbitrarily long delay (i.e. may result in repeated packets if re-sent)

Reliable transport should
* guarantee packet delivery and correctness
* deliver packets in the same order

Reliable data transfer (RDT): service model

![](https://i.imgur.com/qs5JWSt.png)

(The transport layer does all the dirty work. The application layer doesn't perceive anything.)

### rdt 1.0: perfectly reliable channel

### rdt 2.0: channel with bit errors


* Stop and wait protocol
  * Sender sends one packet at a time, then waits for receiver response
  * Acknowledgements (**ACK**s):receiver explicitly tells sender that packet received is OK.
  * Negative acknowledgements (**NAK**s):receiver explicitly tells sender that packet has errors.

In rdt 2.0, sender retransmits packet on receipt of NAK, transmits the next packet on receipt of ACK:

![](https://i.imgur.com/BHJDRqB.png)

### rdt (to be finished)

### Performance of rdt 3.0

#### Stop-and-wait: low utilization & throughput

Let the packet size be $L$ bits, link rate (transmission rate) be $R$ bps, RTT be $RTT$ s

* Sender takes $L/R + RTT$ s to send a packet
* Thus the throughput is $\frac{L}{RTT + D_{trans}} = \frac{L}{RTT + \frac{L}{R}}$

![](https://i.imgur.com/ihVFukO.png)

Utilization is low: $U_{Sender} = \frac{L/R}{RTT+L/R}$, and $RTT$ (propagation delay) is higher than transmission delay.

#### Pipelining: increase utilization

* Pipelining: sender allows multiple, “in-flight”, yet-to-be-acknowledged packets.
  * range of sequence numbers must be increased (for n-packet pipelining, n sequence numbers are needed)
  * buffering at sender and/or receiver

![](https://i.imgur.com/mZua2Zu.png)

**Assumption:** (same as rdt 3.0)

* may flip bits in packets
* may lose packets
* may incur arbitrarily long packet delay
* but **won’t re-order packets**

Two generic forms of pipelined protocols:

* Go-Back-N (GBN)
  * ![](https://i.imgur.com/qSuQPDn.png)
  * Sender
    * allow up to $N$ unACKed packets on the fly
    * insert k-bit sequence number in packet header
    * ignore duplicate ACK
    * use a *sliding window* to keep track of unACKed packets
      * keep a timer for oldest unACKed packet
      * on timeout for packet $x$, re-transmit packets from $x$ to $x+N-1$
        * i.e. *slide* the window after the oldest ACKed packet
  * Receiver
      * only ACK packets that arrive in order
        * *Cumulative ACK*: ACK $m$ means all packets up to packet $m$ are received
        * Nice: ![](https://i.imgur.com/KqgHKfI.png)
        * Bad: ![](https://i.imgur.com/kLBBAtc.png)
      * discard out-of-order packets and ACK the last in-order packet
* Selective repeat (SR)
  * Receiver *individually acknowledges* all correctly received packets.
  * **Buffers** out-of-order packets, as needed, for eventual in-order delivery to upper layer.


## 3.5 TCP (**T**ransport **C**ontrol **P**rotocol)

### Connection-oriented de-mux