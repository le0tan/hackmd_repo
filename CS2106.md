---
title: CS2106 notes
tags: Module, CS2106
---

# Lecture 1: Introduction to OS

## Brief history of OS

- No OS
- Batch OS
  - Execute user program (job) one at a time
  - CPU idle when performing IO
- Time-sharing OS
  - terminals
  - user job scheduling (illusion of concurrency)
  - memory management
  - **virtualization** of hardware

## Motivations of OS

- Abstraction
  - hide low level details
  - *efficiency and portability*
- Resource allocator
  - for better utilization of resources
- Control program
  - prevent errors and improper use
  - provide security and protection

## OS Structure

![](https://i.imgur.com/BOE1p4c.png)

- Kernel mode: have complete access to all **hardware** resources
- User mode: ~limited

Ways to structure an OS:

- Monolithic
  - Pros: well understood; good performance
  - Cons: highly coupled; very complicated
  - ![](https://i.imgur.com/uuKlF6D.png)
- Microkernel
  - Only provides basic and essential facilities
    - Inter-process communication
    - Address space management
    - Thread management
  - Pros: robust&extendable; isolation of kernel from high level services
  - Cons: poorer performance
  - ![](https://i.imgur.com/n2ngtSN.png)

## Virtual machines

### Definition

- a software emulation of hardware
- virtualization of underlying hardware

Also known as **hypervisor**

- Type 1 hypervisor
  - runs directly on hardware
  - ![](https://i.imgur.com/rb2Y64N.png)
- Type 2 hypervisor
  - runs in host OS
  - ![](https://i.imgur.com/xRY6Mq7.png)

# Lecture 2: Process abstraction

Definition: a dynamic **abstraction** to describe an **executing** program (information required to describe a **running program**)

- Memory context
  - code (text), data
- Hardware context
  - registers (or GPR, general purpose registers)
  - PC (program counter, a special register)
- OS context
  - process properties
  - resources used

## Memory context: function call

Important steps:
1. setup parameters
2. transfer control to callee
3. setup local variables
4. store result (if applicable)
5. return control to caller

### Stack memory

Definition: the new memory region to store information about **function invocation**

Content:
- return address of the caller (return PC)
- arguments for the function
- local variables
- saved SP (stack pointer)
- saved FP (frame pointer)

Frame pointer

The frame pointer points to a **fixed location in a stack frame**.

Saved registers

Register spilling
- when GPRs are exhausted
- use memory to temporarily hold GPR value
- restore GPR value from memory afterwards
- a function can do so before the function starts, and restore those registers afterwards

#### Function call convention

* On executing function call:
  * Caller: Pass arguments with registers and/or stack
  * Caller: Save Return PC on stack
* Transfer control from caller to callee
  * Callee: Save registers used by callee. Save old FP, SP
  * Callee: Allocate space for local variables of calleeon stack
  * Callee: Adjust SP to point to new stack top
* On returning from function call:
  * Callee: Restore saved registers, FP, SP
* Transfer control from calleeto caller using saved PC
  * Caller: Continues execution in caller

**Just an example!!**

## Memory context: dynamic allocated memory

![](https://i.imgur.com/z65ADI1.png)

- size not known during compilation 
  - cannot be stored in **Data** region
- no definite deallocation timing
  - no **Stack** region (stack must be in LIFO order, it doesn't support random order of removal)

## OS context: Process ID and process state

### Process state & state transition

![](https://i.imgur.com/ZppZV8K.png)

Global view:

With k CPU(s)
- <= k processes in *running* state
- <= k transition(s) at a time (conceptually 1 transition at a time on 1 CPU)
- Different processes may be in different states

### Queuing model of 5-state transition

![](https://i.imgur.com/5RhAPIy.png)

**Note:** the "queue" is not a real queue (i.e. not necessarily FIFO).

### Process table and process control block (PCB)

![](https://i.imgur.com/KEQqkVr.png)

## Process interaction with OS

### System calls

#### Unix system call in C/C++

* Can be called almost directly
  * function wrapper (similar to alias)
    * e.g. `getpid()`
  * function adapter
    * e.g. `printf()`

#### General syscall mechanism

1. User program invokes the library call (Using the normal function call mechanism as discussed)
2. Library call (usually in assembly code) places the system call number in a designated location (e.g. Register)
3. Library call executes a special instruction to switch from user mode to kernel mode (That instruction is commonly known as **TRAP**)
4. Now in kernel mode, the appropriate system call handler is determined using the system call number as index. (This step is usually handled by a **dispatcher**)
5. System call handler is executed
6. System call handler ended
* Control return to the library call
* Switch from kernel mode to user mode
7. Library call return to the user program via normal function return mechanism

Basically:

call library function 
-> setup syscall number 
-> invoke **TRAP** syscall 
-> determine syscall handler (in kernel mode) 
-> syscall handler handles the request 
-> switch from kernel mode to user mode, control return to library call 
-> library call returns

### Exception and interrupt

Exception
* from executing a machine level instruction
  * e.g. arithmetic errors, memory accessing errors
* is **synchronous**
* Effect
  * execute an **exception handler**
  * similar to a forced function call

Interrupt
* from external events
  * e.g. keyboard interruption
* is **asynchronous**
* Effect
  * program execution is **suspended**
  * execute an **interrupt handler**

## Process management

### Process abstraction in Unix

* Identification
  * PID
* Information
  * process state:
    * running, sleeping, stopped, **zombie**
    * parent PID
    * cumulative CPU time
  * `ps` to show process status
* Creation
  * `fork`
    * ![](https://i.imgur.com/IoLb9Df.png)
    * Child process is a duplicate of the current executable image
      * same code, same address space
      * data is **copied** from the parent (**NOT** shared)
    * Child process differs from parent in
      * pid
      * ppid
      * return value of `fork()` - child returns 0
  * `exec`
    * `execl()` syscall
      * replace current executing process image with a new one
      * only "code replacement", pid and other information still intact
      * ![](https://i.imgur.com/i18PMFX.png)
  * `fork() + execl()`
    * spawn off a child process to perform a task through `exec()`
    * parent process is still intact to accept another request
  * The master process
    * `init`, with pid=1, created in kernel at boot up time
    * watches for other processes and respawns where needed
* Termination
  * `exit`
    * ![](https://i.imgur.com/CdIZgkR.png)
    * `status` is returned to parent process (to be received by `wait()`)
    * 0 means normal exit, other values means abnormal
    * it does **NOT** return
  * Most system resources are released on exit
  * Not releasable:
    * PID & status - for parent-children sync
    * Process accounting info: e.g. CPU time
    * Process table entry (or PCB) **may be** still needed
  * Thus creates **zombie process**
    * cannot completely remove its info (since the parent may `wait()` it)
    * **CANNOT KILL ZOMBIE**
  * Implicit exit
    * return from `main()`
* Parent-child synchronization
  * `wait`
    * ![](https://i.imgur.com/kFszTuQ.png)
    * blocks until **at least one** child process terminates
    * cleans up the remainder of child processes
      * things that are not releasable by `exit()`
      * kill zombie process
  * `waitpid()` - wait for a specific child process
  * `waitid()` - wait for any child process to change status

#### Zombie process (2 cases)

1. Parent process terminates before child

* `init` becomes "pseudo" parent of the child process
* child termination sends signal to `init`, `init` calls `wait()` to do the cleanup

2. Child process terminates before parent, but parent didn't call `wait`

becomes zombie process!

### Process diagram in Unix

![](https://i.imgur.com/uYNYp8E.png)
